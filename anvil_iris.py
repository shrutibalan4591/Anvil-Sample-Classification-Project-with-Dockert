# -*- coding: utf-8 -*-
"""anvil_iris.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iNshnQ2fsZzLX6XQ-cQ529XEl1ct2xig
"""

# WYCXOOC36W22JJSLZYZRGBZK-L33HT7S6SISGMYDS

!pip install anvil-uplink

import anvil.server

anvil.server.connect("WYCXOOC36W22JJSLZYZRGBZK-L33HT7S6SISGMYDS")

import matplotlib.pyplot as plt
from sklearn import metrics
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier

iris = load_iris()
X = iris.data
y = iris.target

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2 , random_state=4)

# The following code is used only when needing to find the optimal n_neighbors
"""
scores = {}
scores_list = []
k_range = range(1, 26)
for k in k_range:
  knn = KNeighborsClassifier(n_neighbors=k)
  knn.fit(X_train, y_train)
  y_pred = knn.predict(X_test)
  scores[k] = metrics.accuracy_score(y_test, y_pred)
  scores_list.append(metrics.accuracy_score(y_test, y_pred))

plt.plot(k_range,scores_list)
plt.xlabel('Value of K for KNN')
plt.ylabel('Testing Accuracy')
"""

knn = KNeighborsClassifier(n_neighbors=10)
knn.fit(X,y)

"""**Creating a callable function**"""

@anvil.server.callable
def predict_iris(sepal_length, sepal_width, petal_length, petal_width):
  classification = knn.predict([[sepal_length, sepal_width, petal_length, petal_width]])
  return iris.target_names[classification][0]

anvil.server.wait_forever()

# https://L33HT7S6SISGMYDS.anvil.app/B7JUJO2HAS56DSWNRMRYAMIP

# https://L33HT7S6SISGMYDS.anvil.app/B7JUJO2HAS56DSWNRMRYAMIP